<?php declare(strict_types = 1);

return PHPStan\Cache\CacheItem::__set_state(array(
   'variableKey' => '/var/www/html/web/core/lib/Drupal/Core/Database/Schema.php-1594234425',
   'data' => 
  array (
    'c890a370cc25057999ddd31e934602b9' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
 * Provides a base implementation for Database Schema.
 */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => NULL,
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '90c429284cc67856935df51794d87fb8' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * The database connection.
   *
   * @var \\Drupal\\Core\\Database\\Connection
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => NULL,
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'c21895c3e9b2cd2d3957d867db6df2d9' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * The placeholder counter.
   *
   * @var int
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => NULL,
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '2c31126b693aaf684b463536a0832835' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Definition of prefixInfo array structure.
   *
   * Rather than redefining DatabaseSchema::getPrefixInfo() for each driver,
   * by defining the defaultSchema variable only MySQL has to re-write the
   * method.
   *
   * @see DatabaseSchema::getPrefixInfo()
   *
   * @var string
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => NULL,
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '3a25608512c5341c970f8371fabfbe69' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * A unique identifier for this query object.
   *
   * @var string
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => NULL,
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '8a2b61f46d62a4457d7ef84f4f3c2b25' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Implements the magic __clone function.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => '__clone',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'cd8d0c526265e840efc688ca59182c86' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * {@inheritdoc}
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'uniqueIdentifier',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '3ab5140bd398fda6c9cbdb0207f764be' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * {@inheritdoc}
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'nextPlaceholder',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '7454a2f54c901409df80e030b5eef868' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Get information about the table name and schema from the prefix.
   *
   * @param
   *   Name of table to look prefix up for. Defaults to \'default\' because that\'s
   *   default key for prefix.
   * @param $add_prefix
   *   Boolean that indicates whether the given table name should be prefixed.
   *
   * @return
   *   A keyed array with information about the schema, table name and prefix.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'getPrefixInfo',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'bbfa6aca79f512f993ef821360cae264' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Create names for indexes, primary keys and constraints.
   *
   * This prevents using {} around non-table names like indexes and keys.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'prefixNonTable',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '90d0f48d3217561a3bfdecb37e373071' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Build a condition to match a table name against a standard information_schema.
   *
   * The information_schema is a SQL standard that provides information about the
   * database server and the databases, schemas, tables, columns and users within
   * it. This makes information_schema a useful tool to use across the drupal
   * database drivers and is used by a few different functions. The function below
   * describes the conditions to be meet when querying information_schema.tables
   * for drupal tables or information associated with drupal tables. Even though
   * this is the standard method, not all databases follow standards and so this
   * method should be overwritten by a database driver if the database provider
   * uses alternate methods. Because information_schema.tables is used in a few
   * different functions, a database driver will only need to override this function
   * to make all the others work. For example see
   * core/includes/databases/mysql/schema.inc.
   *
   * @param $table_name
   *   The name of the table in question.
   * @param $operator
   *   The operator to apply on the \'table\' part of the condition.
   * @param $add_prefix
   *   Boolean to indicate whether the table name needs to be prefixed.
   *
   * @return \\Drupal\\Core\\Database\\Query\\Condition
   *   A Condition object.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'buildTableNameCondition',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'd489e86c80d09527742f0e8072b4aee6' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Check if a table exists.
   *
   * @param $table
   *   The name of the table in drupal (no prefixing).
   *
   * @return
   *   TRUE if the given table exists, otherwise FALSE.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'tableExists',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '99a9a612d96222b5328ee645a00886ff' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Finds all tables that are like the specified base table name.
   *
   * @param string $table_expression
   *   An SQL expression, for example "cache_%" (without the quotes).
   *
   * @return array
   *   Both the keys and the values are the matching tables.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'findTables',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'e28ab608019670409787ce3198934180' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Check if a column exists in the given table.
   *
   * @param $table
   *   The name of the table in drupal (no prefixing).
   * @param $column
   *   The name of the column.
   *
   * @return
   *   TRUE if the given column exists, otherwise FALSE.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'fieldExists',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '595638959f7f55a13437de16107845c1' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Returns a mapping of Drupal schema field names to DB-native field types.
   *
   * Because different field types do not map 1:1 between databases, Drupal has
   * its own normalized field type names. This function returns a driver-specific
   * mapping table from Drupal names to the native names for each database.
   *
   * @return array
   *   An array of Schema API field types to driver-specific field types.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'getFieldTypeMap',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'f5ad83f5be6b6b7d8183aedb008e655a' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Rename a table.
   *
   * @param $table
   *   The table to be renamed.
   * @param $new_name
   *   The new name for the table.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If a table with the specified new name already exists.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'renameTable',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '90a5ed6dc9781f65cd4923d0510841ff' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Drop a table.
   *
   * @param $table
   *   The table to be dropped.
   *
   * @return
   *   TRUE if the table was successfully dropped, FALSE if there was no table
   *   by that name to begin with.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'dropTable',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'fcf09032219e1a3e3d4bac349ec578b4' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Add a new field to a table.
   *
   * @param $table
   *   Name of the table to be altered.
   * @param $field
   *   Name of the field to be added.
   * @param $spec
   *   The field specification array, as taken from a schema definition.
   *   The specification may also contain the key \'initial\', the newly
   *   created field will be set to the value of the key in all rows.
   *   This is most useful for creating NOT NULL columns with no default
   *   value in existing tables.
   *   Alternatively, the \'initial_form_field\' key may be used, which will
   *   auto-populate the new field with values from the specified field.
   * @param $keys_new
   *   (optional) Keys and indexes specification to be created on the
   *   table along with adding the field. The format is the same as a
   *   table specification but without the \'fields\' element. If you are
   *   adding a type \'serial\' field, you MUST specify at least one key
   *   or index including it in this array. See ::changeField() for more
   *   explanation why.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified table already has a field by that name.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'addField',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'dc7e96eef938ece7f150ffc3834ec92c' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Drop a field.
   *
   * @param $table
   *   The table to be altered.
   * @param $field
   *   The field to be dropped.
   *
   * @return
   *   TRUE if the field was successfully dropped, FALSE if there was no field
   *   by that name to begin with.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'dropField',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'f7b0e3f54c9806ef4b95a686773886a1' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Set the default value for a field.
   *
   * @param $table
   *   The table to be altered.
   * @param $field
   *   The field to be altered.
   * @param $default
   *   Default value to be set. NULL for \'default NULL\'.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table or field doesn\'t exist.
   *
   * @deprecated in drupal:8.7.0 and is removed from drupal:9.0.0. Instead,
   *   call ::changeField() passing a full field specification.
   *
   * @see ::changeField()
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'fieldSetDefault',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '0b3b73891b21d2f9e885f08148c22a4f' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Set a field to have no default value.
   *
   * @param $table
   *   The table to be altered.
   * @param $field
   *   The field to be altered.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table or field doesn\'t exist.
   *
   * @deprecated in drupal:8.7.0 and is removed from drupal:9.0.0. Instead,
   *   call ::changeField() passing a full field specification.
   *
   * @see ::changeField()
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'fieldSetNoDefault',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '567429139ead822622de0ed07c6c9ea5' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Checks if an index exists in the given table.
   *
   * @param $table
   *   The name of the table in drupal (no prefixing).
   * @param $name
   *   The name of the index in drupal (no prefixing).
   *
   * @return
   *   TRUE if the given index exists, otherwise FALSE.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'indexExists',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '41e3ec8326639a2be6881c9d0a528159' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Add a primary key.
   *
   * @param $table
   *   The table to be altered.
   * @param $fields
   *   Fields for the primary key.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified table already has a primary key.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'addPrimaryKey',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '35550aa802a79a2acdba059440fe68ba' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Drop the primary key.
   *
   * @param $table
   *   The table to be altered.
   *
   * @return
   *   TRUE if the primary key was successfully dropped, FALSE if there was no
   *   primary key on this table to begin with.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'dropPrimaryKey',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '2c70888785681fc700151167b3fac109' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Finds the primary key columns of a table, from the database.
   *
   * @param string $table
   *   The name of the table.
   *
   * @return string[]|false
   *   A simple array with the names of the columns composing the table\'s
   *   primary key, or FALSE if the table does not exist.
   *
   * @throws \\RuntimeException
   *   If the driver does not override this method.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'findPrimaryKeyColumns',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '22bbc53eedbc5cdbfbcad6f5e9c9c040' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Add a unique key.
   *
   * @param $table
   *   The table to be altered.
   * @param $name
   *   The name of the key.
   * @param $fields
   *   An array of field names.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified table already has a key by that name.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'addUniqueKey',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '33ebbab06ada2ed4e6858c88583671c7' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Drop a unique key.
   *
   * @param $table
   *   The table to be altered.
   * @param $name
   *   The name of the key.
   *
   * @return
   *   TRUE if the key was successfully dropped, FALSE if there was no key by
   *   that name to begin with.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'dropUniqueKey',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'e8001349236a8c546540ab144a7e6ebc' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Add an index.
   *
   * @param $table
   *   The table to be altered.
   * @param $name
   *   The name of the index.
   * @param $fields
   *   An array of field names or field information; if field information is
   *   passed, it\'s an array whose first element is the field name and whose
   *   second is the maximum length in the index. For example, the following
   *   will use the full length of the `foo` field, but limit the `bar` field to
   *   4 characters:
   *   @code
   *     $fields = [\'foo\', [\'bar\', 4]];
   *   @endcode
   * @param array $spec
   *   The table specification for the table to be altered. This is used in
   *   order to be able to ensure that the index length is not too long.
   *   This schema definition can usually be obtained through hook_schema(), or
   *   in case the table was created by the Entity API, through the schema
   *   handler listed in the entity class definition. For reference, see
   *   SqlContentEntityStorageSchema::getDedicatedTableSchema() and
   *   SqlContentEntityStorageSchema::getSharedTableFieldSchema().
   *
   *   In order to prevent human error, it is recommended to pass in the
   *   complete table specification. However, in the edge case of the complete
   *   table specification not being available, we can pass in a partial table
   *   definition containing only the fields that apply to the index:
   *   @code
   *   $spec = [
   *     // Example partial specification for a table:
   *     \'fields\' => [
   *       \'example_field\' => [
   *         \'description\' => \'An example field\',
   *         \'type\' => \'varchar\',
   *         \'length\' => 32,
   *         \'not null\' => TRUE,
   *         \'default\' => \'\',
   *       ],
   *     ],
   *     \'indexes\' => [
   *       \'table_example_field\' => [\'example_field\'],
   *     ],
   *   ];
   *   @endcode
   *   Note that the above is a partial table definition and that we would
   *   usually pass a complete table definition as obtained through
   *   hook_schema() instead.
   *
   * @see schemaapi
   * @see hook_schema()
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified table already has an index by that name.
   *
   * @todo remove the $spec argument whenever schema introspection is added.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'addIndex',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '62cc7f54fdc7c80aeec8ba09fd7463e2' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Drop an index.
   *
   * @param $table
   *   The table to be altered.
   * @param $name
   *   The name of the index.
   *
   * @return
   *   TRUE if the index was successfully dropped, FALSE if there was no index
   *   by that name to begin with.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'dropIndex',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '62e0284836bc38fb3a7e86efe0dfdbe2' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Finds the columns for the primary key, unique keys and indexes of a table.
   *
   * @param string $table
   *   The name of the table.
   *
   * @return array
   *   A schema array with the following keys: \'primary key\', \'unique keys\' and
   *   \'indexes\', and values as arrays of database columns.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table doesn\'t exist.
   * @throws \\RuntimeException
   *   If the driver does not implement this method.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'introspectIndexSchema',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '1a0a44a668469821ab884683ee315e3b' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Change a field definition.
   *
   * IMPORTANT NOTE: To maintain database portability, you have to explicitly
   * recreate all indices and primary keys that are using the changed field.
   *
   * That means that you have to drop all affected keys and indexes with
   * Schema::dropPrimaryKey(), Schema::dropUniqueKey(), or Schema::dropIndex()
   * before calling ::changeField().
   * To recreate the keys and indices, pass the key definitions as the
   * optional $keys_new argument directly to ::changeField().
   *
   * For example, suppose you have:
   * @code
   * $schema[\'foo\'] = array(
   *   \'fields\' => array(
   *     \'bar\' => array(\'type\' => \'int\', \'not null\' => TRUE)
   *   ),
   *   \'primary key\' => array(\'bar\')
   * );
   * @endcode
   * and you want to change foo.bar to be type serial, leaving it as the
   * primary key. The correct sequence is:
   * @code
   * $injected_database->schema()->dropPrimaryKey(\'foo\');
   * $injected_database->schema()->changeField(\'foo\', \'bar\', \'bar\',
   *   array(\'type\' => \'serial\', \'not null\' => TRUE),
   *   array(\'primary key\' => array(\'bar\')));
   * @endcode
   *
   * The reasons for this are due to the different database engines:
   *
   * On PostgreSQL, changing a field definition involves adding a new field
   * and dropping an old one which* causes any indices, primary keys and
   * sequences (from serial-type fields) that use the changed field to be dropped.
   *
   * On MySQL, all type \'serial\' fields must be part of at least one key
   * or index as soon as they are created. You cannot use
   * Schema::addPrimaryKey, Schema::addUniqueKey(), or Schema::addIndex()
   * for this purpose because the ALTER TABLE command will fail to add
   * the column without a key or index specification.
   * The solution is to use the optional $keys_new argument to create the key
   * or index at the same time as field.
   *
   * You could use Schema::addPrimaryKey, Schema::addUniqueKey(), or
   * Schema::addIndex() in all cases unless you are converting a field to
   * be type serial. You can use the $keys_new argument in all cases.
   *
   * @param $table
   *   Name of the table.
   * @param $field
   *   Name of the field to change.
   * @param $field_new
   *   New name for the field (set to the same as $field if you don\'t want to change the name).
   * @param $spec
   *   The field specification for the new field.
   * @param $keys_new
   *   (optional) Keys and indexes specification to be created on the
   *   table along with changing the field. The format is the same as a
   *   table specification but without the \'fields\' element.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectDoesNotExistException
   *   If the specified table or source field doesn\'t exist.
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified destination field already exists.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'changeField',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '527f4cf52348edf0639297f497f34029' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Create a new table from a Drupal table definition.
   *
   * @param $name
   *   The name of the table to create.
   * @param $table
   *   A Schema API table definition array.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaObjectExistsException
   *   If the specified table already exists.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'createTable',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'ef54f97dd9421ef9619f86d872903659' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Return an array of field names from an array of key/index column specifiers.
   *
   * This is usually an identity function but if a key/index uses a column prefix
   * specification, this function extracts just the name.
   *
   * @param $fields
   *   An array of key/index column specifiers.
   *
   * @return
   *   An array of field names.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'fieldNames',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '8a29d9d40b0b86488f06f417b2545a16' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Prepare a table or column comment for database query.
   *
   * @param $comment
   *   The comment string to prepare.
   * @param $length
   *   Optional upper limit on the returned string length.
   *
   * @return
   *   The prepared comment.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'prepareComment',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    'ffe73780d4e4f37b4fe3dbb1dce7654f' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Return an escaped version of its parameter to be used as a default value
   * on a column.
   *
   * @param mixed $value
   *   The value to be escaped (int, float, null or string).
   *
   * @return string|int|float
   *   The escaped value.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'escapeDefaultValue',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
    '7baac5acc2a38fb40992f5fa2669a523' => 
    PHPStan\PhpDoc\NameScopedPhpDocString::__set_state(array(
       'phpDocString' => '/**
   * Ensures that all the primary key fields are correctly defined.
   *
   * @param array $primary_key
   *   An array containing the fields that will form the primary key of a table.
   * @param array $fields
   *   An array containing the field specifications of the table, as per the
   *   schema data structure format.
   *
   * @throws \\Drupal\\Core\\Database\\SchemaException
   *   Thrown if any primary key field specification does not exist or if they
   *   do not define \'not null\' as TRUE.
   */',
       'nameScope' => 
      PHPStan\Analyser\NameScope::__set_state(array(
         'namespace' => 'Drupal\\Core\\Database',
         'uses' => 
        array (
          'placeholderinterface' => 'Drupal\\Core\\Database\\Query\\PlaceholderInterface',
        ),
         'className' => 'Drupal\\Core\\Database\\Schema',
         'functionName' => 'ensureNotNullPrimaryKey',
         'templateTypeMap' => 
        PHPStan\Type\Generic\TemplateTypeMap::__set_state(array(
           'types' => 
          array (
          ),
        )),
      )),
    )),
  ),
));